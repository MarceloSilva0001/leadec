<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Renomeador de PDFs - LEADEC</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background: #f8f9fa;
    }
  
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      border-radius: 10px;
      padding: 32px;
      box-shadow: 0 0 30px #0002;
    }
  
    .progress-bar {
      height: 22px;
      background: #e9ecef;
      border-radius: 8px;
      margin-bottom: 12px;
      overflow: hidden;
    }
  
    .progress {
      height: 100%;
      background: #2d90f5;
      width: 0;
      transition: width 0.2s;
    }
  
    .status {
      margin-bottom: 10px;
      font-size: 1.1em;
      color: #2d90f5;
    }
  
    .tabs {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }
  
    .tab-btn {
      padding: 7px 22px;
      border: none;
      border-radius: 8px 8px 0 0;
      background: #e9ecef;
      cursor: pointer;
      color: #444;
      font-weight: bold;
    }
  
    .tab-btn.active {
      background: #2d90f5;
      color: #fff;
    }
  
    ul {
      font-size: 0.97em;
      color: #333;
      margin: 0;
      padding-left: 20px;
    }
  
    .error {
      color: #c00;
      font-weight: bold;
    }
  
    .success {
      color: #090;
      font-weight: bold;
    }
  
    input[type="file"] {
      padding: 10px;
    }
  
    a, button:not(.tab-btn) {
      margin-top: 20px;
      padding: 10px 30px;
      border: none;
      border-radius: 6px;
      background: #2d90f5;
      color: #fff;
      font-size: 1.1em;
      cursor: pointer;
    }
  
    button:disabled {
      background: #999;
      cursor: not-allowed;
    }
  
    .tab-content {
      display: none;
      min-height: 32px;
    }
  
    .tab-content.active {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <a href="index.html">Voltar</a>
    <h2>Renomeador de Pontos (PDFs)</h2>
    <input type="file" id="fileInput" accept="application/pdf" multiple><br>
    <div class="progress-bar"><div class="progress" id="progress"></div></div>
    <div class="status" id="status">Aguardando arquivos...</div>
    
    <div class="tabs">
      <button class="tab-btn active" id="tabSuccess">Sucesso</button>
      <button class="tab-btn" id="tabError">Erros</button>
    </div>
    <div id="successContent" class="tab-content active">
      <ul id="logSuccess"></ul>
    </div>
    <div id="errorContent" class="tab-content">
      <ul id="logError"></ul>
    </div>
    <button id="downloadBtn" style="display:none">Baixar PDFs renomeados (.zip)</button>
  </div>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

<script>
const fileInput = document.getElementById('fileInput');
const status = document.getElementById('status');
const progress = document.getElementById('progress');
const logSuccess = document.getElementById('logSuccess');
const logError = document.getElementById('logError');
const downloadSuccessBtn = document.createElement('button');
const downloadErrorBtn = document.createElement('button');

downloadSuccessBtn.textContent = 'Baixar Sucessos (.zip)';
downloadErrorBtn.textContent = 'Baixar Erros (.zip)';
downloadSuccessBtn.style.display = 'none';
downloadErrorBtn.style.display = 'none';
document.querySelector('.container').appendChild(downloadSuccessBtn);
document.querySelector('.container').appendChild(downloadErrorBtn);

// Tabs
tabSuccess.onclick = () => {
  tabSuccess.classList.add('active');
  tabError.classList.remove('active');
  successContent.classList.add('active');
  errorContent.classList.remove('active');
};
tabError.onclick = () => {
  tabError.classList.add('active');
  tabSuccess.classList.remove('active');
  errorContent.classList.add('active');
  successContent.classList.remove('active');
};

function sanitizeFileName(name) {
  return name
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/[\\/:*?"<>|()]+/g, '')
    .replace(/\s+/g, ' ').trim();
}

function findColaboradorName(text) {
  const lines = text.split('\n').map(line => line.trim());
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].toUpperCase().includes('NOME') && i > 0) {
      const nomeLine = lines[i - 1].trim();
      if (nomeLine === nomeLine.toUpperCase() &&
          nomeLine.split(' ').length >= 2 &&
          nomeLine.split(' ').every(word => word.length > 2)) {
        return nomeLine;
      }
    }
  }
  const namePattern = /^([A-ZÀ-Ú]{3,}(?:\s+[A-ZÀ-Ú]{3,})+)$/;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(namePattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return null;
}

async function processMultiPagePDF(file) {
  logSuccess.innerHTML = '';
  logError.innerHTML = '';
  downloadSuccessBtn.style.display = 'none';
  downloadErrorBtn.style.display = 'none';
  status.innerHTML = `Carregando PDF...`;

  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const totalPages = pdf.numPages;

  let zipSuccess = new JSZip();
  let zipError = new JSZip();
  let nameCounts = {};
  let renamed = 0, failed = 0;

  for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
    status.innerHTML = `Processando página ${pageNum}/${totalPages}...`;
    progress.style.width = `${(pageNum / totalPages) * 100}%`;

    try {
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale: 2 });
      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const context = canvas.getContext('2d');
      await page.render({ canvasContext: context, viewport }).promise;

      // Extrair texto
      const content = await page.getTextContent();
      const text = content.items.map(i => i.str).join('\n');
      const nome = findColaboradorName(text);

      // Criar um PDF novo com 1 imagem
      const imgDataUrl = canvas.toDataURL('image/png');
      const pdfDoc = await PDFLib.PDFDocument.create();
      const img = await pdfDoc.embedPng(imgDataUrl);
      const pageNew = pdfDoc.addPage([img.width, img.height]);
      pageNew.drawImage(img, {
        x: 0,
        y: 0,
        width: img.width,
        height: img.height,
      });
      const newPdfBytes = await pdfDoc.save();

      // Renomear ou jogar nos erros
      if (!nome) {
        const errorName = `pagina_${pageNum}.pdf`;
        zipError.file(errorName, newPdfBytes);
        logError.innerHTML += `<li class="error">[Página ${pageNum}] Nome não identificado</li>`;
        failed++;
        continue;
      }

      let safeName = sanitizeFileName(nome);
      if (nameCounts[safeName]) {
        nameCounts[safeName]++;
        safeName += ` (${nameCounts[safeName]})`;
      } else {
        nameCounts[safeName] = 1;
      }

      const newFileName = `${safeName}.pdf`;
      zipSuccess.file(newFileName, newPdfBytes);
      logSuccess.innerHTML += `<li class="success">[Página ${pageNum}] &rarr; <b>${newFileName}</b></li>`;
      renamed++;

    } catch (err) {
      logError.innerHTML += `<li class="error">[Página ${pageNum}] Erro: ${err.message}</li>`;
      failed++;
    }
  }

  status.innerHTML = `<b>Finalizado:</b> ${renamed} sucesso(s), ${failed} erro(s).`;
  downloadSuccessBtn.style.display = renamed ? 'inline-block' : 'none';
  downloadErrorBtn.style.display = failed ? 'inline-block' : 'none';

  if (renamed) {
    downloadSuccessBtn.onclick = async () => {
      status.innerHTML = 'Gerando ZIP de sucessos...';
      const blob = await zipSuccess.generateAsync({ type: 'blob' });
      saveAs(blob, 'pdfs_sucesso.zip');
      status.innerHTML = 'Download dos sucessos pronto!';
    };
  }

  if (failed) {
    downloadErrorBtn.onclick = async () => {
      status.innerHTML = 'Gerando ZIP de erros...';
      const blob = await zipError.generateAsync({ type: 'blob' });
      saveAs(blob, 'pdfs_erro.zip');
      status.innerHTML = 'Download dos erros pronto!';
    };
  }

  progress.style.width = '100%';
}

async function processMultipleSinglePagePDFs(files) {
  logSuccess.innerHTML = '';
  logError.innerHTML = '';
  downloadSuccessBtn.style.display = 'none';
  downloadErrorBtn.style.display = 'none';
  status.innerHTML = `Carregando arquivos (${files.length})...`;

  let zipSuccess = new JSZip();
  let zipError = new JSZip();
  let nameCounts = {};
  let renamed = 0, failed = 0;

  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    status.innerHTML = `Processando arquivo ${i + 1}/${files.length}...`;
    progress.style.width = `${((i + 1) / files.length) * 100}%`;

    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const page = await pdf.getPage(1);
      const viewport = page.getViewport({ scale: 2 });
      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const context = canvas.getContext('2d');
      await page.render({ canvasContext: context, viewport }).promise;

      // Extrair texto
      const content = await page.getTextContent();
      const text = content.items.map(i => i.str).join('\n');
      const nome = findColaboradorName(text);

      // Criar PDF novo com imagem da página
      const imgDataUrl = canvas.toDataURL('image/png');
      const pdfDoc = await PDFLib.PDFDocument.create();
      const img = await pdfDoc.embedPng(imgDataUrl);
      const pageNew = pdfDoc.addPage([img.width, img.height]);
      pageNew.drawImage(img, {
        x: 0,
        y: 0,
        width: img.width,
        height: img.height,
      });
      const newPdfBytes = await pdfDoc.save();

      if (!nome) {
        const errorName = `arquivo_${i + 1}.pdf`;
        zipError.file(errorName, newPdfBytes);
        logError.innerHTML += `<li class="error">[${file.name}] Nome não identificado</li>`;
        failed++;
        continue;
      }

      let safeName = sanitizeFileName(nome);
      if (nameCounts[safeName]) {
        nameCounts[safeName]++;
        safeName += ` (${nameCounts[safeName]})`;
      } else {
        nameCounts[safeName] = 1;
      }

      const newFileName = `${safeName}.pdf`;
      zipSuccess.file(newFileName, newPdfBytes);
      logSuccess.innerHTML += `<li class="success">[${file.name}] &rarr; <b>${newFileName}</b></li>`;
      renamed++;

    } catch (err) {
      logError.innerHTML += `<li class="error">[${file.name}] Erro: ${err.message}</li>`;
      failed++;
    }
  }

  status.innerHTML = `<b>Finalizado:</b> ${renamed} sucesso(s), ${failed} erro(s).`;
  downloadSuccessBtn.style.display = renamed ? 'inline-block' : 'none';
  downloadErrorBtn.style.display = failed ? 'inline-block' : 'none';

  if (renamed) {
    downloadSuccessBtn.onclick = async () => {
      status.innerHTML = 'Gerando ZIP de sucessos...';
      const blob = await zipSuccess.generateAsync({ type: 'blob' });
      saveAs(blob, 'pdfs_sucesso.zip');
      status.innerHTML = 'Download dos sucessos pronto!';
    };
  }

  if (failed) {
    downloadErrorBtn.onclick = async () => {
      status.innerHTML = 'Gerando ZIP de erros...';
      const blob = await zipError.generateAsync({ type: 'blob' });
      saveAs(blob, 'pdfs_erro.zip');
      status.innerHTML = 'Download dos erros pronto!';
    };
  }

  progress.style.width = '100%';
}


fileInput.addEventListener('change', async (e) => {
  const files = Array.from(e.target.files).filter(f => f.type === 'application/pdf');
  if (!files.length) {
    status.innerHTML = '<span class="error">Nenhum arquivo PDF selecionado!</span>';
    return;
  }

  if (files.length === 1) {
    try {
      const arrayBuffer = await files[0].arrayBuffer(); // ✅ CORRIGIDO
      const doc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      if (doc.numPages > 1) {
        await processMultiPagePDF(files[0]);
      } else {
        await processMultipleSinglePagePDFs(files);
      }

    } catch (err) {
      status.innerHTML = `<span class="error">Erro ao abrir o PDF: ${err.message}</span>`;
    }

  } else {
    // Múltiplos arquivos → processa um por um
    await processMultipleSinglePagePDFs(files);
  }
});


</script>

</body>
</html>
